<?php
/**
 * Manages Sutra-specific database handling. This does not extend off
 *   fDatabase. Instead, it manages an instance of fDatabase.
 *
 * @copyright Copyright (c) 2011 Poluza.
 * @author Andrew Udvare [au] <andrew@poluza.com>
 * @license http://www.opensource.org/licenses/mit-license.php
 *
 * @package Sutra
 * @link http://www.example.com/
 *
 * @version 1.0
 */
class sDatabase {
  /**
   * The type of database.
   *
   * @var string
   */
  protected $type;

  /**
   * Database name.
   *
   * @var string
   */
  protected $name;

  /**
   * The user name to access the database.
   *
   * @var string
   */
  protected $user;

  /**
   * The database host.
   *
   * @var string
   */
  protected $host;

  /**
   * The database port.
   *
   * @var int
   */
  protected $port;

  /**
   * The database time-out time.
   *
   * @var int
   */
  protected $timeout;

  /**
   * Whether or not schema caching is enabled.
   *
   * @var bool
   */
  protected $schema_caching_enabled;

  /**
   * The fDatabase instance.
   *
   * @var fDatabase
   */
  protected $dbh;

  /**
   * The sDatabase instance.
   *
   * @var sDatabase
   */
  protected static $instance;

  /**
   * Throws an exception if the INI file is not readable or cannot be parsed.
   *
   * @throws fEnvironmentException If the site configuration INI file cannot
   *   be read.
   *
   * @param string $file File name.
   * @return array Array if the file could be parsed.
   */
  private static function readINIFile($file) {
    if (!is_readable($file) || ($ini = parse_ini_file($file)) === FALSE) {
      throw new fEnvironmentException('Database configuration file could not be read.');
    }
    return $ini;
  }

  /**
   * Attach the ORM to the default database. Also enables fORM schema caching
   *   if $this->schema_caching_enabled is TRUE.
   *
   * @return void
   */
  protected function attachORM() {
    // Connect the ORM
    fORMDatabase::attach($this->dbh);
    if ($this->schema_caching_enabled) {
      fORM::enableSchemaCaching(sCache::getInstance());
    }
  }

  /**
   * Validate the required files of the INI file (after parsing).
   *
   * @param array $ini Array generated by parse_ini_file() or similar.
   * @return boolean TRUE if the array is valid.
   */
  private static function validateINI(array $ini) {
    if (!$ini['type'] || !$ini['name']) {
      throw new fEnvironmentException('Type and name must be specified in database configuration file.');
    }
    return TRUE;
  }

  /**
   * Cast a value to a different type.
   *
   * @param mixed $value Value to cast to.
   * @param string $cast_to The type to cast to. One of: integer, boolean.
   * @return mixed The casted value.
   */
  private static function cast($value, $cast_to) {
    switch ($cast_to) {
      case 'integer':
        return (int)$value;

      case 'boolean':
        return (bool)$value;
    }
    return $value;
  }

  /**
   * Read a key from the parsed array from the INI file.
   *
   * @param array $ini Array made with parse_ini_file() or similar.
   * @param string $key Key to read.
   * @param string $cast_to Type to cast to.
   * @param mixed $default_value Default value to return if the value does not
   *   exist.
   * @param boolean $existed If the value is in the INI file (reference).
   * @return mixed The value or the default value if the key cannot be found.
   */
  private static function readINIValue(array $ini, $key, $cast_to = 'string', $default_value = NULL, &$existed = FALSE) {
    if (isset($ini[$key])) {
      $existed = TRUE;
      return self::cast($ini[$key], $cast_to);
    }

    return $default_value;
  }

  /**
   * Constructor. Private to prevent external instantiation.
   *
   * @throws fEnvironmentException If the configuration file cannot be read; if
   *   connection details are invalid.
   *
   * @return sDatabase
   */
  public function __construct() {
    $file = sConfiguration::getPath().'/database.ini';
    $ini = self::readINIFile($file);
    $timeout_existed = FALSE;
    $port_existed = FALSE;

    // type and database are required
    self::validateINI($ini);

    $this->type = strtolower($ini['type']);
    $this->name = $ini['name'];
    $this->user = self::readINIValue($ini, 'user');
    $password = self::readINIValue($ini, 'password');
    $this->host = self::readINIValue($ini, 'host', 'integer');
    $this->port = self::readINIValue($ini, 'port', 'integer', FALSE, $port_existed);
    $this->timeout = self::readINIValue($ini, 'timeout', 'integer', FALSE, $timeout_existed);
    $this->schema_caching_enabled = self::readINIValue($ini, 'schema_caching', 'boolean', FALSE);

    if ($this->port === FALSE && $port_existed) {
      throw new fEnvironmentException('Only integers are allowed for port.');
    }
    if ($this->timeout === FALSE && $timeout_existed) {
      throw new fEnvironmentException('Timeout must be an integer.');
    }

    if ($this->type == 'sqlite') {
      $this->dbh = new fDatabase($this->type, $this->name);
    }
    else {
      $this->dbh = new fDatabase($this->type, $this->name, $this->user, $password, $this->host, $this->port, $this->timeout);
    }

    if ($this->schema_caching_enabled) {
      $this->dbh->enableCaching(sCache::getInstance());
    }

    $this->attachORM();
  }

  /**
   * Get existing fDatabase object in any state.
   *
   * @return fDatabase
   */
  protected function getfDatabase() {
    return $this->dbh;
  }

  /**
   * Mainly because this is a singleton class that manages the connection via fDatabase.
   *
   * @return fDatabase Contrary to name, this returns the fDatabase instance
   *   rather than the sDatabase instance.
   */
  public static function getInstance() {
    if (!self::$instance) {
      self::$instance = new self;
    }

    return self::$instance->getfDatabase();
  }

  /**
   * __callStatic implementation. Call any fDatabase method with this but
   *   statically with sDatabase.
   *
   * @param string $method Method to use.
   * @param array $arguments Arguments to use.
   */
  public static function __callStatic($method, $arguments) {
    return fCore::call(array(self::getInstance(), $method), $arguments);
  }
}
